# backend/services/forecasting.py
"""
Forecasting Service for BioHIVE Disease Surveillance System

Provides read-only access to ML-generated forecast results stored in the database.
This service does NOT compute forecasts - it only retrieves and formats existing predictions.
"""

from datetime import date, datetime, timedelta
from typing import Dict, List, Optional, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, desc
from backend.schemas import ForecastResult


class ForecastService:
    """
    Service for retrieving and formatting ML forecast results.
    
    Provides read-only access to predictions generated by the ML team's forecast engine.
    Does not perform any ML computations - only queries and formats existing data.
    """
    
    # Valid symptom types
    VALID_SYMPTOMS = {'fever', 'cough', 'gi', 'all'}
    
    def __init__(self, db: Session):
        """
        Initialize forecasting service.
        
        Args:
            db: SQLAlchemy database session
        """
        self.db = db
    
    def get_forecast(
        self,
        symptom: Optional[str] = None,
        days: int = 7,
        forecast_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """
        Retrieve forecast results for specified symptom(s) and time range.
        
        Args:
            symptom: Symptom type ('fever', 'cough', 'gi', 'all', or None).
                    None or 'all' returns all symptoms grouped.
            days: Number of days to forecast ahead (default: 7)
            forecast_date: Specific forecast generation date to retrieve.
                          If None, uses most recent forecast.
        
        Returns:
            Dictionary structured for dashboard consumption:
            {
                'forecast_metadata': {
                    'forecast_date': date,
                    'generated_at': datetime,
                    'prediction_days': int,
                    'model_name': str,
                    'symptoms_included': list
                },
                'forecasts': {
                    'fever': [...],
                    'cough': [...],
                    'gi': [...]
                },
                'summary': {
                    'total_predictions': int,
                    'date_range': {
                        'start': date,
                        'end': date
                    }
                }
            }
        
        Raises:
            ValueError: If symptom type or days parameter is invalid
            RuntimeError: If database query fails
        """
        # Validate inputs
        if symptom is not None and symptom.lower() not in self.VALID_SYMPTOMS:
            raise ValueError(
                f"Invalid symptom '{symptom}'. Must be one of: {', '.join(self.VALID_SYMPTOMS)}"
            )
        
        if days < 1 or days > 365:
            raise ValueError(f"days must be between 1 and 365, got {days}")
        
        # Normalize symptom parameter
        symptom_filter = None if (symptom is None or symptom.lower() == 'all') else symptom.lower()
        
        try:
            # Determine which forecast_date to use
            target_forecast_date = self._get_target_forecast_date(forecast_date)
            
            if target_forecast_date is None:
                # No forecasts exist in database
                return self._empty_forecast_response(symptom_filter, days)
            
            # Calculate prediction date range
            end_date = target_forecast_date + timedelta(days=days)
            
            # Build query
            query = self.db.query(ForecastResult).filter(
                and_(
                    ForecastResult.forecast_date == target_forecast_date,
                    ForecastResult.prediction_date > target_forecast_date,
                    ForecastResult.prediction_date <= end_date
                )
            )
            
            # Apply symptom filter if specified
            if symptom_filter:
                query = query.filter(ForecastResult.symptom == symptom_filter)
            
            # Execute query and order by prediction date
            forecasts = query.order_by(ForecastResult.prediction_date).all()
            
            if not forecasts:
                return self._empty_forecast_response(symptom_filter, days, target_forecast_date)
            
            # Format response
            return self._format_forecast_response(
                forecasts,
                target_forecast_date,
                days,
                symptom_filter
            )
            
        except ValueError:
            # Re-raise validation errors
            raise
        except Exception as e:
            raise RuntimeError(f"Failed to retrieve forecast: {str(e)}")
    
    def get_latest_forecast_date(self) -> Optional[date]:
        """
        Get the most recent forecast generation date in the database.
        
        Returns:
            Latest forecast_date or None if no forecasts exist
        """
        try:
            result = self.db.query(ForecastResult.forecast_date).order_by(
                desc(ForecastResult.forecast_date)
            ).first()
            
            return result[0] if result else None
            
        except Exception as e:
            raise RuntimeError(f"Failed to retrieve latest forecast date: {str(e)}")
    
    def get_available_models(self) -> List[str]:
        """
        Get list of all model names used in stored forecasts.
        
        Returns:
            List of unique model names
        """
        try:
            results = self.db.query(ForecastResult.model_name).distinct().all()
            return [r[0] for r in results]
            
        except Exception as e:
            raise RuntimeError(f"Failed to retrieve model names: {str(e)}")
    
    def get_forecast_by_model(
        self,
        model_name: str,
        symptom: Optional[str] = None,
        days: int = 7
    ) -> Dict[str, Any]:
        """
        Retrieve forecasts for a specific model.
        
        Args:
            model_name: Name of the model (e.g., 'prophet', 'arima', 'ensemble')
            symptom: Symptom type filter
            days: Number of days to forecast ahead
        
        Returns:
            Formatted forecast response for the specified model
        
        Raises:
            ValueError: If model_name is invalid or not found
        """
        if not model_name or not isinstance(model_name, str):
            raise ValueError("model_name must be a non-empty string")
        
        # Normalize symptom parameter
        symptom_filter = None if (symptom is None or symptom.lower() == 'all') else symptom.lower()
        
        try:
            # Get latest forecast date for this model
            latest = self.db.query(ForecastResult.forecast_date).filter(
                ForecastResult.model_name == model_name
            ).order_by(desc(ForecastResult.forecast_date)).first()
            
            if not latest:
                raise ValueError(f"No forecasts found for model '{model_name}'")
            
            target_forecast_date = latest[0]
            end_date = target_forecast_date + timedelta(days=days)
            
            # Build query
            query = self.db.query(ForecastResult).filter(
                and_(
                    ForecastResult.model_name == model_name,
                    ForecastResult.forecast_date == target_forecast_date,
                    ForecastResult.prediction_date > target_forecast_date,
                    ForecastResult.prediction_date <= end_date
                )
            )
            
            if symptom_filter:
                query = query.filter(ForecastResult.symptom == symptom_filter)
            
            forecasts = query.order_by(ForecastResult.prediction_date).all()
            
            if not forecasts:
                return self._empty_forecast_response(
                    symptom_filter, days, target_forecast_date, model_name
                )
            
            return self._format_forecast_response(
                forecasts,
                target_forecast_date,
                days,
                symptom_filter,
                model_name
            )
            
        except ValueError:
            raise
        except Exception as e:
            raise RuntimeError(f"Failed to retrieve forecast for model '{model_name}': {str(e)}")
    
    def _get_target_forecast_date(self, forecast_date: Optional[date]) -> Optional[date]:
        """
        Determine which forecast_date to use for queries.
        
        Args:
            forecast_date: User-specified date or None
        
        Returns:
            Target forecast_date or None if no forecasts exist
        """
        if forecast_date is not None:
            # Verify the specified date exists
            exists = self.db.query(ForecastResult).filter(
                ForecastResult.forecast_date == forecast_date
            ).first()
            
            if not exists:
                raise ValueError(f"No forecasts found for date {forecast_date}")
            
            return forecast_date
        else:
            # Use most recent forecast
            return self.get_latest_forecast_date()
    
    def _format_forecast_response(
        self,
        forecasts: List[ForecastResult],
        forecast_date: date,
        days: int,
        symptom_filter: Optional[str],
        model_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Format raw forecast results into dashboard-ready structure.
        
        Args:
            forecasts: List of ForecastResult objects from database
            forecast_date: Date when forecast was generated
            days: Number of days forecasted
            symptom_filter: Symptom filter applied (or None for all)
            model_name: Specific model filter (or None)
        
        Returns:
            Formatted forecast dictionary
        """
        # Group forecasts by symptom
        grouped = {'fever': [], 'cough': [], 'gi': []}
        symptoms_included = set()
        
        for forecast in forecasts:
            symptom_type = forecast.symptom.lower()
            symptoms_included.add(symptom_type)
            
            forecast_entry = {
                'date': forecast.prediction_date,
                'predicted_value': forecast.predicted_value,
                'lower_bound': forecast.lower_bound,
                'upper_bound': forecast.upper_bound,
                'confidence': float(forecast.confidence),
                'model': forecast.model_name
            }
            
            if symptom_type in grouped:
                grouped[symptom_type].append(forecast_entry)
        
        # Remove empty symptom groups if filtering
        if symptom_filter:
            grouped = {k: v for k, v in grouped.items() if k == symptom_filter}
        else:
            grouped = {k: v for k, v in grouped.items() if v}
        
        # Calculate date range
        prediction_dates = [f.prediction_date for f in forecasts]
        date_range = {
            'start': min(prediction_dates) if prediction_dates else forecast_date,
            'end': max(prediction_dates) if prediction_dates else forecast_date + timedelta(days=days)
        }
        
        # Get model name from first forecast
        used_model = model_name or (forecasts[0].model_name if forecasts else 'unknown')
        
        # Get generation timestamp from first forecast
        generated_at = forecasts[0].created_at if forecasts else datetime.utcnow()
        
        return {
            'forecast_metadata': {
                'forecast_date': forecast_date,
                'generated_at': generated_at,
                'prediction_days': days,
                'model_name': used_model,
                'symptoms_included': sorted(list(symptoms_included))
            },
            'forecasts': grouped,
            'summary': {
                'total_predictions': len(forecasts),
                'date_range': date_range,
                'symptoms_count': len(symptoms_included)
            }
        }
    
    def _empty_forecast_response(
        self,
        symptom_filter: Optional[str],
        days: int,
        forecast_date: Optional[date] = None,
        model_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Generate empty response when no forecasts are found.
        
        Args:
            symptom_filter: Symptom filter applied
            days: Number of days requested
            forecast_date: Forecast date (if known)
            model_name: Model name (if known)
        
        Returns:
            Empty forecast response structure
        """
        symptoms = [symptom_filter] if symptom_filter else ['fever', 'cough', 'gi']
        
        return {
            'forecast_metadata': {
                'forecast_date': forecast_date,
                'generated_at': None,
                'prediction_days': days,
                'model_name': model_name or 'none',
                'symptoms_included': symptoms
            },
            'forecasts': {symptom: [] for symptom in symptoms},
            'summary': {
                'total_predictions': 0,
                'date_range': {
                    'start': None,
                    'end': None
                },
                'symptoms_count': 0
            }
        }
    
    def get_forecast_summary(self) -> Dict[str, Any]:
        """
        Get high-level summary of all available forecasts.
        
        Returns:
            Dictionary containing:
            {
                'total_forecasts': int,
                'latest_forecast_date': date,
                'oldest_forecast_date': date,
                'available_models': list,
                'symptoms_covered': list,
                'date_coverage': {
                    'earliest_prediction': date,
                    'latest_prediction': date
                }
            }
        """
        try:
            total = self.db.query(ForecastResult).count()
            
            if total == 0:
                return {
                    'total_forecasts': 0,
                    'latest_forecast_date': None,
                    'oldest_forecast_date': None,
                    'available_models': [],
                    'symptoms_covered': [],
                    'date_coverage': {
                        'earliest_prediction': None,
                        'latest_prediction': None
                    }
                }
            
            # Get date ranges
            latest_forecast = self.db.query(ForecastResult.forecast_date).order_by(
                desc(ForecastResult.forecast_date)
            ).first()[0]
            
            oldest_forecast = self.db.query(ForecastResult.forecast_date).order_by(
                ForecastResult.forecast_date
            ).first()[0]
            
            earliest_prediction = self.db.query(ForecastResult.prediction_date).order_by(
                ForecastResult.prediction_date
            ).first()[0]
            
            latest_prediction = self.db.query(ForecastResult.prediction_date).order_by(
                desc(ForecastResult.prediction_date)
            ).first()[0]
            
            # Get unique models and symptoms
            models = [r[0] for r in self.db.query(ForecastResult.model_name).distinct().all()]
            symptoms = [r[0] for r in self.db.query(ForecastResult.symptom).distinct().all()]
            
            return {
                'total_forecasts': total,
                'latest_forecast_date': latest_forecast,
                'oldest_forecast_date': oldest_forecast,
                'available_models': sorted(models),
                'symptoms_covered': sorted(symptoms),
                'date_coverage': {
                    'earliest_prediction': earliest_prediction,
                    'latest_prediction': latest_prediction
                }
            }
            
        except Exception as e:
            raise RuntimeError(f"Failed to retrieve forecast summary: {str(e)}")